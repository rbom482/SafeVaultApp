using System;
using System.Collections.Generic;
using Microsoft.Data.SqlClient;
using SafeVaultApp.Configuration;
using SafeVaultApp.Helpers;
using SafeVaultApp.Logging;
using SafeVaultApp.Services;

namespace SafeVaultApp.Tests
{
    /// <summary>
    /// Security vulnerability testing class that identifies and tests potential security issues.
    /// This class demonstrates how to debug and resolve security vulnerabilities using Microsoft Copilot.
    /// Implements comprehensive testing for SQL injection, XSS, and other OWASP Top 10 vulnerabilities.
    /// </summary>
    public static class SecurityVulnerabilityTests
    {
        /// <summary>
        /// Runs all security vulnerability tests and demonstrates debugging process.
        /// </summary>
        public static void RunAllVulnerabilityTests()
        {
            Console.WriteLine("=== Security Vulnerability Testing & Debugging ===");
            Console.WriteLine("Identifying and testing potential security vulnerabilities...\n");

            try
            {
                // Test SQL injection vulnerabilities
                TestSQLInjectionVulnerabilities();

                // Test XSS vulnerabilities
                TestXSSVulnerabilities();

                // Test input validation edge cases
                TestInputValidationEdgeCases();

                // Test authentication bypass attempts
                TestAuthenticationBypassAttempts();

                // Test authorization vulnerabilities
                TestAuthorizationVulnerabilities();

                // Test information disclosure vulnerabilities
                TestInformationDisclosureVulnerabilities();

                // Test session management vulnerabilities
                TestSessionManagementVulnerabilities();

                Console.WriteLine("\n=== Vulnerability Testing Complete ===");
                Console.WriteLine("All security tests completed. Review results above for any issues.");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"ERROR: Unexpected error during vulnerability testing: {ex.Message}");
            }
        }

        /// <summary>
        /// Tests for SQL injection vulnerabilities with malicious payloads.
        /// Demonstrates how to identify and prevent SQL injection attacks.
        /// </summary>
        private static void TestSQLInjectionVulnerabilities()
        {
            Console.WriteLine("--- SQL Injection Vulnerability Tests ---");

            var config = SecurityConfiguration.CreateFromEnvironment();
            var logger = new ConsoleSecurityLogger();
            var authService = new AuthenticationService(config, logger);

            // Advanced SQL injection payloads
            var sqlInjectionPayloads = new[]
            {
                // Classic SQL injection attempts
                "admin'; DROP TABLE Users; --",
                "'; DELETE FROM Users WHERE '1'='1'; --",
                "' OR '1'='1",
                "admin'--",
                "admin' #",
                
                // Union-based SQL injection
                "' UNION SELECT username, password FROM admin_users --",
                "' UNION SELECT 1,2,3,4,5 --",
                
                // Time-based blind SQL injection
                "'; WAITFOR DELAY '00:00:05'; --",
                "' AND (SELECT COUNT(*) FROM Users) > 0 WAITFOR DELAY '00:00:02'; --",
                
                // Boolean-based blind SQL injection
                "' AND (SELECT SUBSTRING(username,1,1) FROM Users WHERE username='admin')='a'; --",
                
                // Error-based SQL injection
                "' AND (SELECT * FROM (SELECT COUNT(*),CONCAT(version(),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a); --",
                
                // Second-order SQL injection
                "test'; INSERT INTO Users (username, password) VALUES ('hacker', 'password'); --",
                
                // NoSQL injection attempts (for comprehensive testing)
                "'; return db.collection.find(); }//",
                "admin' || '1'=='1",
                
                // LDAP injection
                "admin*)(uid=*))(|(uid=*",
                
                // XML injection
                "'; --></test><script>alert('XSS')</script><!--"
            };

            Console.WriteLine("Testing authentication with SQL injection payloads:");
            
            foreach (var payload in sqlInjectionPayloads)
            {
                try
                {
                    // Test username injection
                    bool result1 = authService.LoginUser(payload, "password123");
                    string status1 = result1 ? "❌ VULNERABLE" : "✅ BLOCKED";
                    Console.WriteLine($"  {status1} - Username: {payload.Substring(0, Math.Min(50, payload.Length))}...");

                    // Test password injection
                    bool result2 = authService.LoginUser("testuser", payload);
                    string status2 = result2 ? "❌ VULNERABLE" : "✅ BLOCKED";
                    Console.WriteLine($"  {status2} - Password injection with same payload");

                    // Brief pause to avoid overwhelming the system
                    System.Threading.Thread.Sleep(10);
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"  ✅ EXCEPTION HANDLED - {ex.GetType().Name}: Payload properly rejected");
                }
            }

            // Test stored procedure injection
            Console.WriteLine("\nTesting stored procedure parameter injection:");
            TestStoredProcedureInjection(authService);

            Console.WriteLine();
        }

        /// <summary>
        /// Tests stored procedure parameter injection vulnerabilities.
        /// </summary>
        private static void TestStoredProcedureInjection(AuthenticationService authService)
        {
            var storedProcInjectionPayloads = new[]
            {
                "admin'; EXEC xp_cmdshell 'dir'; --",
                "'; EXEC sp_configure 'show advanced options', 1; --",
                "admin'; EXEC master..xp_servicecontrol 'start', 'telnet'; --",
                "'; DECLARE @cmd varchar(8000); SET @cmd = 'net user hacker password /add'; EXEC master..xp_cmdshell @cmd; --"
            };

            foreach (var payload in storedProcInjectionPayloads)
            {
                try
                {
                    // Test role checking with injection
                    string? role = authService.GetUserRole(payload);
                    string status = (role != null && role != "user") ? "❌ VULNERABLE" : "✅ BLOCKED";
                    Console.WriteLine($"  {status} - Stored proc injection: {payload.Substring(0, Math.Min(40, payload.Length))}...");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"  ✅ EXCEPTION HANDLED - Stored procedure injection blocked: {ex.GetType().Name}");
                }
            }
        }

        /// <summary>
        /// Tests for XSS vulnerabilities with comprehensive attack vectors.
        /// Demonstrates identification and prevention of cross-site scripting attacks.
        /// </summary>
        private static void TestXSSVulnerabilities()
        {
            Console.WriteLine("--- XSS Vulnerability Tests ---");

            // Comprehensive XSS attack vectors
            var xssPayloads = new[]
            {
                // Basic script injection
                "<script>alert('XSS')</script>",
                "<SCRIPT>alert('XSS')</SCRIPT>",
                "<ScRiPt>alert('XSS')</ScRiPt>",
                
                // Event handler injection
                "<img src=x onerror=alert('XSS')>",
                "<svg onload=alert('XSS')>",
                "<iframe src='javascript:alert(\"XSS\")'></iframe>",
                "<body onload=alert('XSS')>",
                "<input onfocus=alert('XSS') autofocus>",
                "<marquee onstart=alert('XSS')>",
                
                // URL-based XSS
                "javascript:alert('XSS')",
                "data:text/html,<script>alert('XSS')</script>",
                "vbscript:alert('XSS')",
                
                // DOM-based XSS vectors
                "'-alert('XSS')-'",
                "\";alert('XSS');//",
                "</script><script>alert('XSS')</script>",
                
                // Filter evasion techniques
                "<img src=\"javascript:alert('XSS')\">",
                "<img src=# onmouseover=\"alert('XSS')\">",
                "<img src=# onmouseover=alert('XSS')>",
                "<<SCRIPT>alert('XSS');//<</SCRIPT>",
                "<img src=\"jav&#x09;ascript:alert('XSS')\">",
                "<img src=\"jav&#x0A;ascript:alert('XSS')\">",
                "<img src=\"jav&#x0D;ascript:alert('XSS')\">",
                
                // CSS-based XSS
                "<style>@import'http://ha.ckers.org/xss.css';</style>",
                "<link rel=\"stylesheet\" href=\"http://ha.ckers.org/xss.css\">",
                "<style>body{background:url(\"javascript:alert('XSS')\")}</style>",
                
                // XML/XHTML injection
                "<xml onreadystatechange=\"alert('XSS')\">",
                "<?xml version=\"1.0\"?><root><![CDATA[<script>alert('XSS')</script>]]></root>",
                
                // Object/embed injection
                "<object data=\"data:text/html,<script>alert('XSS')</script>\">",
                "<embed src=\"data:text/html,<script>alert('XSS')</script>\">",
                "<applet code=\"alert('XSS')\">",
                
                // Meta refresh injection
                "<meta http-equiv=\"refresh\" content=\"0;url=javascript:alert('XSS')\">",
                
                // Form-based XSS
                "<form action=\"javascript:alert('XSS')\"><input type=\"submit\">",
                
                // Advanced encoding techniques
                "%3Cscript%3Ealert('XSS')%3C/script%3E",
                "&#60;script&#62;alert('XSS')&#60;/script&#62;",
                "&lt;script&gt;alert('XSS')&lt;/script&gt;",
                
                // Unicode XSS
                "<script>alert('XSS')</script>",
                "\\u003cscript\\u003ealert('XSS')\\u003c/script\\u003e",
                
                // Template injection
                "{{alert('XSS')}}",
                "${alert('XSS')}",
                "#{alert('XSS')}",
                
                // AngularJS injection
                "{{constructor.constructor('alert(\"XSS\")')()}}",
                "{{$new.constructor('alert(\"XSS\")')()}}",
                
                // React injection
                "javascript:/*--></title></style></textarea></script></xmp><svg/onload='+/\"/+/onmouseover=1/+/[*/[]/+alert('XSS')//'>",
                
                // Server-side template injection
                "{{7*7}}",
                "${7*7}",
                "#{7*7}",
                "<%= 7*7 %>",
                
                // NoScript bypass
                "<noscript><p title=\"</noscript><img src=x onerror=alert('XSS')>\">",
                
                // Context-aware XSS
                "';alert('XSS');//",
                "\";alert('XSS');//",
                "');alert('XSS');//",
                "\");alert('XSS');//"
            };

            Console.WriteLine("Testing XSS protection against comprehensive attack vectors:");

            int blockedCount = 0;
            int vulnerableCount = 0;

            foreach (var payload in xssPayloads)
            {
                try
                {
                    bool isSafe = ValidationHelpers.IsValidXSSInput(payload);
                    string sanitized = ValidationHelpers.SanitizeInput(payload);
                    
                    if (!isSafe)
                    {
                        blockedCount++;
                        Console.WriteLine($"  ✅ BLOCKED - {payload.Substring(0, Math.Min(60, payload.Length))}...");
                    }
                    else
                    {
                        vulnerableCount++;
                        Console.WriteLine($"  ❌ POTENTIAL VULNERABILITY - {payload.Substring(0, Math.Min(60, payload.Length))}...");
                        Console.WriteLine($"      Sanitized: {sanitized.Substring(0, Math.Min(60, sanitized.Length))}...");
                    }
                }
                catch (Exception ex)
                {
                    blockedCount++;
                    Console.WriteLine($"  ✅ EXCEPTION HANDLED - XSS payload rejected: {ex.GetType().Name}");
                }
            }

            Console.WriteLine($"\nXSS Test Summary:");
            Console.WriteLine($"  ✅ Blocked: {blockedCount}");
            Console.WriteLine($"  ❌ Potential vulnerabilities: {vulnerableCount}");
            Console.WriteLine($"  Security Rating: {(blockedCount * 100.0 / (blockedCount + vulnerableCount)):F1}%");
            Console.WriteLine();
        }

        /// <summary>
        /// Tests input validation edge cases and boundary conditions.
        /// </summary>
        private static void TestInputValidationEdgeCases()
        {
            Console.WriteLine("--- Input Validation Edge Case Tests ---");

            var edgeCaseInputs = new[]
            {
                // Null and empty inputs
                null,
                "",
                " ",
                "\t",
                "\n",
                "\r\n",
                
                // Extremely long inputs (buffer overflow attempts)
                new string('A', 10000),
                new string('A', 100000),
                
                // Unicode and encoding attacks
                "test\x00null",
                "test\x1Fcontrol",
                "test\x7Fdelete",
                "test\uFEFFbom",
                "test\uFFFEreverse",
                "test\uFFFFno-char",
                
                // Path traversal
                "../../../etc/passwd",
                "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
                "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
                
                // Command injection
                "; ls -la",
                "| dir",
                "&& whoami",
                "|| id",
                "`whoami`",
                "$(whoami)",
                
                // LDAP injection
                "*",
                "*)(&",
                "*)(uid=*",
                "*)(|(uid=*",
                
                // XML injection
                "]]></value><script>alert('XSS')</script><value><![CDATA[",
                "<?xml version=\"1.0\"?><!DOCTYPE root [<!ENTITY test SYSTEM 'file:///etc/passwd'>]><root>&test;</root>",
                
                // Format string attacks
                "%s%s%s%s%s%s%s%s%s%s",
                "%x%x%x%x%x%x%x%x%x%x",
                "%n%n%n%n%n%n%n%n%n%n",
                
                // Integer overflow
                "2147483647",
                "2147483648",
                "-2147483648",
                "-2147483649",
                
                // Floating point edge cases
                "1.7976931348623157E+308",
                "-1.7976931348623157E+308",
                "NaN",
                "Infinity",
                "-Infinity"
            };

            Console.WriteLine("Testing input validation with edge cases:");

            int passedCount = 0;
            int failedCount = 0;

            foreach (var input in edgeCaseInputs)
            {
                try
                {
                    bool isValid = ValidationHelpers.IsValidInput(input ?? "");
                    bool isXSSSafe = ValidationHelpers.IsValidXSSInput(input ?? "");
                    string sanitized = ValidationHelpers.SanitizeInput(input ?? "");

                    string inputDisplay = input == null ? "NULL" : 
                                        input.Length > 50 ? $"{input.Substring(0, 47)}..." : 
                                        input.Replace("\n", "\\n").Replace("\r", "\\r").Replace("\t", "\\t");

                    if (!isValid || !isXSSSafe)
                    {
                        passedCount++;
                        Console.WriteLine($"  ✅ REJECTED - {inputDisplay}");
                    }
                    else
                    {
                        failedCount++;
                        Console.WriteLine($"  ⚠️  ACCEPTED - {inputDisplay}");
                        if (sanitized != (input ?? ""))
                        {
                            Console.WriteLine($"      Sanitized to: {sanitized.Substring(0, Math.Min(50, sanitized.Length))}...");
                        }
                    }
                }
                catch (Exception ex)
                {
                    passedCount++;
                    Console.WriteLine($"  ✅ EXCEPTION - Edge case properly handled: {ex.GetType().Name}");
                }
            }

            Console.WriteLine($"\nEdge Case Test Summary:");
            Console.WriteLine($"  ✅ Properly handled: {passedCount}");
            Console.WriteLine($"  ⚠️  Needs review: {failedCount}");
            Console.WriteLine();
        }

        /// <summary>
        /// Tests for authentication bypass vulnerabilities.
        /// </summary>
        private static void TestAuthenticationBypassAttempts()
        {
            Console.WriteLine("--- Authentication Bypass Tests ---");

            var config = SecurityConfiguration.CreateFromEnvironment();
            var logger = new ConsoleSecurityLogger();
            var authService = new AuthenticationService(config, logger);

            // Authentication bypass payloads
            var bypassAttempts = new[]
            {
                // SQL injection authentication bypass
                new { Username = "admin' --", Password = "anything" },
                new { Username = "admin'/*", Password = "anything" },
                new { Username = "admin' OR '1'='1' --", Password = "anything" },
                new { Username = "admin' OR 1=1 --", Password = "anything" },
                new { Username = "' OR '1'='1", Password = "' OR '1'='1" },
                new { Username = "') OR ('1'='1", Password = "anything" },
                
                // NoSQL injection bypass
                new { Username = "admin", Password = "anything' || '1'=='1" },
                new { Username = "admin", Password = "{\"$ne\": null}" },
                new { Username = "admin", Password = "{\"$gt\": \"\"}" },
                
                // LDAP injection bypass
                new { Username = "admin)(uid=*", Password = "anything" },
                new { Username = "admin)(&(uid=*", Password = "anything" },
                
                // Timing attack attempts
                new { Username = "admin", Password = "a" },
                new { Username = "admin", Password = "ab" },
                new { Username = "admin", Password = "abc" },
                
                // Case sensitivity bypass
                new { Username = "ADMIN", Password = "password" },
                new { Username = "Admin", Password = "password" },
                new { Username = "aDmIn", Password = "password" },
                
                // Unicode normalization bypass
                new { Username = "admin", Password = "pāssword" },
                new { Username = "āmin", Password = "password" },
                
                // Null byte injection
                new { Username = "admin\x00", Password = "password" },
                new { Username = "admin", Password = "password\x00" },
                
                // Parameter pollution
                new { Username = "admin&username=guest", Password = "password" },
                new { Username = "admin", Password = "password&password=123" }
            };

            Console.WriteLine("Testing authentication bypass attempts:");

            foreach (var attempt in bypassAttempts)
            {
                try
                {
                    var startTime = DateTime.UtcNow;
                    bool result = authService.LoginUser(attempt.Username, attempt.Password);
                    var elapsed = DateTime.UtcNow - startTime;

                    string status = result ? "❌ BYPASSED" : "✅ BLOCKED";
                    string timing = elapsed.TotalMilliseconds > 100 ? $" (⚠️ Slow: {elapsed.TotalMilliseconds:F0}ms)" : "";
                    
                    Console.WriteLine($"  {status} - {attempt.Username} / {attempt.Password.Substring(0, Math.Min(20, attempt.Password.Length))}...{timing}");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"  ✅ EXCEPTION - Bypass attempt blocked: {ex.GetType().Name}");
                }
            }

            Console.WriteLine();
        }

        /// <summary>
        /// Tests for authorization vulnerabilities and privilege escalation.
        /// </summary>
        private static void TestAuthorizationVulnerabilities()
        {
            Console.WriteLine("--- Authorization Vulnerability Tests ---");

            var config = SecurityConfiguration.CreateFromEnvironment();
            var logger = new ConsoleSecurityLogger();
            var authService = new AuthenticationService(config, logger);

            // Test privilege escalation attempts
            var privilegeEscalationTests = new[]
            {
                // Direct role manipulation attempts
                new { Username = "user'; UPDATE Users SET UserRole='admin' WHERE Username='user'; --", Role = "admin" },
                new { Username = "user", Role = "admin'; INSERT INTO Users (Username, UserRole) VALUES ('hacker', 'admin'); --" },
                
                // Parameter tampering
                new { Username = "normaluser", Role = "admin" },
                new { Username = "guest", Role = "moderator" },
                
                // Session hijacking simulation
                new { Username = "admin' OR '1'='1", Role = "user" },
                
                // Case sensitivity bypass
                new { Username = "normaluser", Role = "ADMIN" },
                new { Username = "normaluser", Role = "Admin" },
                
                // Role enumeration
                new { Username = "normaluser", Role = "superadmin" },
                new { Username = "normaluser", Role = "root" },
                new { Username = "normaluser", Role = "administrator" },
                
                // Unicode bypass
                new { Username = "normaluser", Role = "ādmin" },
                
                // Null byte injection
                new { Username = "normaluser", Role = "admin\x00" },
                
                // Array/object injection
                new { Username = "normaluser", Role = "[\"admin\", \"user\"]" },
                new { Username = "normaluser", Role = "{\"role\": \"admin\"}" }
            };

            Console.WriteLine("Testing privilege escalation attempts:");

            foreach (var test in privilegeEscalationTests)
            {
                try
                {
                    bool isAuthorized = authService.IsUserAuthorized(test.Username, test.Role);
                    string status = isAuthorized ? "❌ ESCALATION POSSIBLE" : "✅ BLOCKED";
                    Console.WriteLine($"  {status} - User: {test.Username.Substring(0, Math.Min(30, test.Username.Length))}... Role: {test.Role}");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"  ✅ EXCEPTION - Escalation blocked: {ex.GetType().Name}");
                }
            }

            // Test horizontal privilege escalation
            Console.WriteLine("\nTesting horizontal privilege escalation:");
            TestHorizontalPrivilegeEscalation(authService);

            Console.WriteLine();
        }

        /// <summary>
        /// Tests horizontal privilege escalation attempts.
        /// </summary>
        private static void TestHorizontalPrivilegeEscalation(AuthenticationService authService)
        {
            var horizontalTests = new[]
            {
                // User ID manipulation
                new { OriginalUser = "user1", TargetUser = "user2", Method = "ID manipulation" },
                new { OriginalUser = "user1", TargetUser = "admin", Method = "Admin access attempt" },
                new { OriginalUser = "guest", TargetUser = "user1", Method = "Guest escalation" },
                
                // Session token manipulation (simulated)
                new { OriginalUser = "user1", TargetUser = "user2", Method = "Token manipulation" },
                
                // Cookie manipulation (simulated)
                new { OriginalUser = "user1", TargetUser = "admin", Method = "Cookie manipulation" }
            };

            foreach (var test in horizontalTests)
            {
                try
                {
                    // Simulate accessing another user's data
                    var userData = authService.GetUserData(12345); // Random user ID
                    string status = userData != null ? "⚠️  DATA ACCESSED" : "✅ ACCESS DENIED";
                    Console.WriteLine($"  {status} - {test.Method}: {test.OriginalUser} -> {test.TargetUser}");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"  ✅ EXCEPTION - Horizontal escalation blocked: {ex.GetType().Name}");
                }
            }
        }

        /// <summary>
        /// Tests for information disclosure vulnerabilities.
        /// </summary>
        private static void TestInformationDisclosureVulnerabilities()
        {
            Console.WriteLine("--- Information Disclosure Tests ---");

            var config = SecurityConfiguration.CreateFromEnvironment();
            var logger = new ConsoleSecurityLogger();
            var authService = new AuthenticationService(config, logger);

            // Test error message information disclosure
            var errorDisclosureTests = new[]
            {
                // Database error disclosure
                "admin'; SELECT 1/0; --",
                "admin'; SELECT * FROM non_existent_table; --",
                
                // File path disclosure
                "admin'; SELECT LOAD_FILE('/etc/passwd'); --",
                "admin'; SELECT LOAD_FILE('C:\\Windows\\System32\\drivers\\etc\\hosts'); --",
                
                // System information disclosure
                "admin'; SELECT @@version; --",
                "admin'; SELECT USER(); --",
                "admin'; SELECT DATABASE(); --",
                
                // Schema information disclosure
                "admin'; SELECT table_name FROM information_schema.tables; --",
                "admin'; SELECT column_name FROM information_schema.columns; --"
            };

            Console.WriteLine("Testing information disclosure through error messages:");

            foreach (var test in errorDisclosureTests)
            {
                try
                {
                    bool result = authService.LoginUser(test, "password");
                    Console.WriteLine($"  ✅ NO DISCLOSURE - Payload handled safely");
                }
                catch (SqlException ex)
                {
                    // Check if SQL error messages contain sensitive information
                    string errorMsg = ex.Message.ToLower();
                    bool containsSensitiveInfo = errorMsg.Contains("database") || 
                                               errorMsg.Contains("table") || 
                                               errorMsg.Contains("column") ||
                                               errorMsg.Contains("server") ||
                                               errorMsg.Contains("login") ||
                                               errorMsg.Contains("password");
                    
                    string status = containsSensitiveInfo ? "❌ INFORMATION LEAKED" : "✅ SAFE ERROR";
                    Console.WriteLine($"  {status} - SQL Exception handled");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"  ✅ SAFE ERROR - {ex.GetType().Name} handled without disclosure");
                }
            }

            Console.WriteLine();
        }

        /// <summary>
        /// Tests for session management vulnerabilities.
        /// </summary>
        private static void TestSessionManagementVulnerabilities()
        {
            Console.WriteLine("--- Session Management Tests ---");

            // Since this is a console app, we'll simulate session management testing
            var sessionTests = new[]
            {
                "Session fixation attacks",
                "Session hijacking attempts",
                "Concurrent session handling",
                "Session timeout validation",
                "Secure session token generation",
                "Session invalidation on logout",
                "Cross-domain session security"
            };

            Console.WriteLine("Session management security areas to verify:");

            foreach (var test in sessionTests)
            {
                Console.WriteLine($"  ℹ️  {test} - Manual verification required");
            }

            // Test secure random generation (used for session tokens)
            Console.WriteLine("\nTesting random number generation quality:");
            TestRandomNumberQuality();

            Console.WriteLine();
        }

        /// <summary>
        /// Tests the quality of random number generation for security purposes.
        /// </summary>
        private static void TestRandomNumberQuality()
        {
            var randomValues = new HashSet<string>();
            int duplicates = 0;
            int totalTests = 1000;

            for (int i = 0; i < totalTests; i++)
            {
                // Simulate salt generation logic
                byte[] randomBytes = new byte[32];
                using (var rng = System.Security.Cryptography.RandomNumberGenerator.Create())
                {
                    rng.GetBytes(randomBytes);
                }
                string randomValue = Convert.ToBase64String(randomBytes);

                if (!randomValues.Add(randomValue))
                {
                    duplicates++;
                }
            }

            double uniquenessPercentage = ((double)(totalTests - duplicates) / totalTests) * 100;
            string status = uniquenessPercentage > 99.9 ? "✅ HIGH QUALITY" : "❌ WEAK RANDOMNESS";
            
            Console.WriteLine($"  {status} - Random generation quality: {uniquenessPercentage:F2}% unique ({duplicates} duplicates in {totalTests} tests)");
        }
    }
}
